#!/usr/bin/env ruby

# An RSpec wrapper that cuts down on the clutter
# and makes it easier to re-run failing tests.
#
# run:
#   rtest --help
# to see full usage options.
#
#
require 'json'
require 'open3'
require 'optparse'
require 'tempfile'

# in case you use byebug or binding.pry
require 'expect'
require 'io/wait'
require 'pty'
require 'stringio'


USAGE=<<~EOL
rtest is a convenience tool to make life easier when dealing with RSpec.

Output is limited to actionable details about failing tests and
just enough to get you to the right place to fix them.

rtest also has a number of options for making it trivial to rerun
failing tests without needing to specify paths and line numbers.

Version: VERSION_NUMBER_HERE

USAGE:

rtest [-h | --help | help]
  display these usage instructions

rtest
  shows you numbered list of last test failures (if any)

rtest all
  run _all_ rspect tests

rtest last_file
  finds the last file that had a problem
  and runs all the tests in it.

rtest <n>
  re-run a specific failure from the last test
  as identified by its number

rtest <n> +/-<x>
  re-run a specific failure from the last test
  as identified by its number
  BUT offset the line number of the test +/- x
  (useful if you've added or removed lines above it)

  Ex. rtest 5 +2
  runs example number 5 but specifes a line number 2 greater
  than the initial failure reported.

rtest <path_to/file_spec.rb>
  run a specific spec and captures failures (if any)
  you can run it with the optional line number syntax too
  E.g. rtest path_to/file_spec.rb
    or rtest path_to/file_spec.rb:32

rtest kill <number>
  removes the test with the specified number from the
  list of past failures

rtest kill <number>-<number>
  removes the tests with numbers within the specified
  range of past failure numbers (inclusive).

rtest rerun
  runs all the past failures
  functionally identical to calling with just the
  number for each of the known failures.

rtest file <number>
  outputs the file path from the test with that number

rtest files
  outputs a list of all the files+line numbers of failing tests

VERBOSE MODE

rtest -v <any prior command>
  instead of "marching ants" verbose mode will print out the names
  of classes under test as their respective tests are being run.

RTEST_AUTO_VERBOSE
  rtest will watch for an RTEST_AUTO_VERBOSE environment varible.
  If this is set to a number > 0 rtest will automatically turn on
  verbose mode after that many seconds.

RTEST DEVELOPERS

rtest [-t<TEST_FILE_PATH>|--test=<TEST_FILE_PATH>]
  this will specify a test file that will be used for input
  instead of running rspec.

  It is expected that it will be paired with a file of the same
  name but with the _expected_output suffix. For example:

  test_0.txt should have a corresponding test_0_expected_output.txt

EOL
USAGE.freeze

# SET UP THE COLORS
ERROR_LINE_COLOR="\e[38;5;196m"
FILE_HIGHLIGHT_COLOR="\e[38;5;7m"
EXPECTED_LINE_COLOR="\e[32m"
GOT_LINE_COLOR="\e[38;5;7m" #"\e[91m"
LINE_NUMBER_COLOR="\e[38;5;214m" # was 100;33
ERROR_HERE_LINE_COLOR="\e[1;38;5;7m" # "\e[100,37m"
COLOR_RESET="\e[0m"
DETAIL_LINE_COLOR="\e[38;2;255;140;0m"


# The regex to match ANSI codes
# from https://github.com/piotrmurach/strings-ansi
ANSI_MATCHER = %r{
  (?>\033(
    \[[\[?>!]?\d*(;\d+)*[ ]?[a-zA-Z~@$^\]_\{\\] # graphics
    |
    \#?\d # cursor modes
    |
    [)(%+\-*/. ](\d|[a-zA-Z@=%]|) # character sets
    |
    O[p-xA-Z] # special keys
    |
    [a-zA-Z=><~\}|] # cursor movement
    |
    \]8;[^;]*;.*?(\033\\|\07) # hyperlink
  ))
}x.freeze


NO_FAILURES_TEXT="\n‚úÖ No failures."

PAST_RUN_FILENAME=".rtest.json"

@options = {}
OptionParser.new do |parser|
  parser.banner = "Usage: example.rb [options]"

  parser.on("-v", "--verbose", "Run verbosely") do |v|
    @options[:verbose] = v
  end

  parser.on("-tTEST_FILE", "--test=TEST_FILE", "path to test file") do |tf|
    @options[:test_file] = tf
    @options[:expected_output_file] = tf.sub(/\.txt$/, "_expected_output.txt")
  end

  parser.on("-aSECONDS", "--auto-verbose=SECONDS", "Switch to verbose mode if run takes more than SECONDS") do | s |
    @options[:auto_verbose_seconds] = s.to_i
  end
end.parse!


VERBOSE = @options.has_key? :verbose
if @options.has_key?(:auto_verbose_seconds)
  AUTO_VERBOSE = @options[:auto_verbose_seconds]
else
  AUTO_VERBOSE = ENV['RTEST_AUTO_VERBOSE'].to_i
end
TEST_MODE = @options.has_key? :test_file

START=Time.now.to_i

past_run_data = {}
# looks like
# {
#   failures: [
#     {
#       message: "",
#       details: "",
#       file: "",
#       line_number: 123
#       expected: ""
#       got: "",
#       diff: ""
#     }
#   ]
# }

################
# terminal interactivity stuff
# in case you use binding.pry or byebug
# type things
def currently_verbose?
  @current_verboseness_state ||= VERBOSE
  return true if @current_verboseness_state
  if AUTO_VERBOSE > 0 && (Time.now.to_i - START) >= AUTO_VERBOSE
    if @current_verboseness_state == false
      puts "\n‚ÑπÔ∏è  Auto-enabling \"Verbose mode\" after #{AUTO_VERBOSE} seconds.\n"
      @current_verboseness_state = true
    end
    return true
  end
  false
end

def process_running?(pid)
  Process.getpgid(pid)
  true # or boom
rescue
  false
end

def unescape(text)
  text.gsub(ANSI_MATCHER, "")
end
def buffer_last_line(buffer)
  last_line = buffer.string.split("\n").last
  return nil unless last_line
  # $stderr.puts("XXX last_line (#{lines.size}): '#{unescape(last_line).strip}'\n")
  unescape(last_line)
end

def definite_debugger_line(line)
  return false unless line
  # puts "line.inspect: '#{line.inspect}'"
  !! line.match(/^\(byebug\) $|^\[\d+\] pry\(.*?\)> $/)
end
def potential_debugger_pause(line)
  !! line.match(/^\s*\d+:\s+/)
end

def wait_for_read(reader, pid, last_line, counter = 0)
  # counter is a count of times through this with
  # potential debugger pause lines
  running = process_running?(pid)
  while running && ! reader.ready?
    putc "." unless currently_verbose? #ironically
    return :debugger if definite_debugger_line(last_line)
    if last_line && potential_debugger_pause(last_line)
      counter += 1
      return :debugger if counter > 4
    end
    sleep 0.2
  end
  if running
    :running
  else
    :ready
  end
end

def read_into_buffer(reader, buffer)
  temp_buffer = StringIO.new("")
  loop do
    break unless reader.ready?
    char = reader.read(1)
    break if char.nil?
    temp_buffer.putc(char)
  end

  temp_string = unescape(temp_buffer.string)
  if temp_string.length > 0
    if currently_verbose? && temp_string.strip.length > 0
      test_names = extract_test_names(temp_string)
      if test_names.size > 0
        puts "\t‚§è #{test_names.join("\n\t‚§è ")}"
      end
    end

    buffer << temp_string
  end
end

def extract_test_names(string)
  lines = string.split("\n")
  lines.select{|l| /^[A-Z][\w\d]*(?:::[A-Z][\w\d]*)*\s*$/.match(l)}
end

################



def display_failures(failures)
  failures.each_with_index do | failure, idx |
    display_failure(failure, idx)
  end
end

def reformat_failure_details(details)
  details_lines = details.split("\n")
  if details_lines.size > 2
    # 2 because it's typically
    # [0]<error line>\n[1]<blank line>\n[2]<error message>
    (2..(details_lines.size - 1) ).each do | idx |
      details_lines[idx] = "\t‚ñ∫#{details_lines[idx]}"
    end
  end
  "\t" + details_lines.join("\n")
end

def display_failure(failure, index)
    puts "\n#{ERROR_LINE_COLOR}#{index + 1}: #{failure["message"]}#{COLOR_RESET}\n"
    puts printable_file_and_line_num(failure)

    if ! failure["details"].nil?
      formatted_details = reformat_failure_details(failure["details"])
      puts "#{DETAIL_LINE_COLOR}#{formatted_details}#{COLOR_RESET}"
    end

    puts "\t\t#{EXPECTED_LINE_COLOR}expected: #{failure["expected"]}#{COLOR_RESET}" if failure.has_key? "expected"
    puts "\t\t#{GOT_LINE_COLOR}got     : #{failure["got"]}#{COLOR_RESET}" if failure.has_key? "got"

    puts "\n\t\tDiff:\n#{failure["diff"].join("\n\t\t")}" if failure.has_key? "diff"

end
def printable_file_and_line_num(failure)
  if failure["spec_file"]
    line = "#{ failure["file"].nil? ? "\t" : ""}#{ERROR_HERE_LINE_COLOR}#{failure["spec_file_full_path"]}#{COLOR_RESET}:#{LINE_NUMBER_COLOR}#{failure["spec_file_line_number"]}#{COLOR_RESET}"
	# details on fd and what it takes can be found here
	# https://github.com/sharkdp/fd#readme

    if failure["file"]
      line = "\tFAILED SPEC: " + line
      line += "\n\tERROR HERE : #{ERROR_HERE_LINE_COLOR}#{failure["file_full_path"]}#{COLOR_RESET}:#{LINE_NUMBER_COLOR}#{failure["line_number"]}#{COLOR_RESET}"
    else
      line = "\n\tERROR HERE : " + line
    end
    line
  else
    "\tERROR HERE : #{ERROR_HERE_LINE_COLOR}#{failure["file"]}#{COLOR_RESET}:#{LINE_NUMBER_COLOR}#{failure["line_number"]}#{COLOR_RESET}"
  end
end

def process_rspec_output(output)
  new_run_data = {"failures" => []}
  output_lines = output.split("\n")
  in_failure = false
  in_diff = false
  current_failure = {}
  top_failure=""
  in_sub_failure = false
  output_lines.each_with_index do | line, idx |
    if not in_failure
      match_data =  /^\s+\d+(\.\d+)*\)\s+(.*)/.match(line)
      if match_data
        # starting a new failure
        in_failure = true
        in_sub_failure = match_data[1].nil? ? false : true
        # if ! in_sub_failure
          unless current_failure.empty?
            new_run_data['failures'] << current_failure
            display_failure(current_failure, new_run_data['failures'].length - 1)
          end
        # end
        top_failure = match_data[2]
        current_failure = {}
        current_failure["message"] = match_data[2]
      # else, random crap we don't care about
      end
    else
      # in a failure, and past the initial line
      details_match = /^\s+(\d+(?:\.\d+)*\)\s+)?Failure\/Error:\s*(.*)/.match(line)

      expected_match = /^\s+expected:\s+(.*)/.match(line)

      # seriously RSpec? Why can't you be consistent?
      got_match = /^\s+(?:got|received):\s+(.*)/.match(line)

      trace_match = /^\s+#\s+(.*?\/(.*?\.rb)):(\d+):in /.match(line)
      spec_match = /^\s+#\s+((?:\.\/)?spec\/.*?\/(.*?_spec\.rb)):(\d+):in /.match(line)
      # ^^^ https://regexper.com/#%5E%5Cs%2B%23%5Cs%2B%28%28%3F%3A%5C.%5C%2F%29%3Fspec%5C%2F.*%3F%5C%2F%28.*%3F%5C.rb%29%29%3A%28%5Cd%2B%29%3Ain%20

      diff_match = /^\s+Diff:\s*/.match(line)

      something_match = /^\s+\w+.*/.match(line)

      finished_match = /^Finished in \d+\.\d+ seconds/.match(line)

      if finished_match
        in_sub_failure = false
        in_failure=false
      elsif details_match
        if ! details_match[1].nil?
          # we're in a sub-failure
          in_sub_failure = true
          current_failure = {} # reset
          current_failure["message"] = "#{top_failure}\n\t#{details_match[2]}"
        end

        current_failure["details"] = details_match[2]
      elsif expected_match
        current_failure["expected"] = expected_match[1]
      elsif got_match
        current_failure["got"] = got_match[1]
      elsif spec_match && current_failure["spec_file"].nil?
        current_failure["spec_file"] = spec_match[2]
        current_failure["spec_file_full_path"] = spec_match[1]
        current_failure["spec_file_line_number"] = spec_match[3]
        top_failure = ""
        in_failure = false
        in_sub_failure = false
        in_diff = false
      elsif trace_match and (current_failure["file"] || current_failure["spec_file"])
        in_diff = false
        current_failure["file"] = trace_match[2]
        current_failure["file_full_path"] = trace_match[1]
        current_failure["line_number"] = trace_match[3]
        unless current_failure["spec_file"].nil?
          in_failure = false
          in_sub_failure = false
          top_failure = ""
        end
      elsif trace_match
        current_failure["file"] = trace_match[2]
        current_failure["file_full_path"] = trace_match[1]
        current_failure["line_number"] = trace_match[3]
      elsif diff_match && ! in_diff
        in_diff = true
        current_failure["diff"] = []
          # ends when we get to the trace_match
          # don't want the first line since it's just "Diff:"
      elsif in_diff
        current_failure["diff"] << line.lstrip
      elsif current_failure.has_key? "details"
        #we're somewhere between the Failure/Error line
        #and the stack trace
        if ! is_ignorable_detail(line)
          current_failure["details"] += "\n#{line}"
        end
      elsif in_sub_failure && ! something_match.nil?
        if ! is_ignorable_detail(line)
          if current_failure["details"]
            current_failure["details"] += "\n#{line}"
          else
            current_failure["details"] = "\n#{line}"
          end
        end
      end

    end
  end
  unless current_failure.empty?
    new_run_data['failures'] << current_failure
    display_failure(current_failure, new_run_data['failures'].length - 1)
  end
  new_run_data
end


def interactive_run_handler(run_line, output_buffer)
  PTY.spawn(run_line) do |reader, writer, pid|
    if process_running?(pid)
      while process_running?(pid)
        wait_response = wait_for_read(reader, pid, buffer_last_line(output_buffer))
        if wait_response != :running # ready or debugger
          read_into_buffer(reader, output_buffer)
          # break unless process_running?(pid)
          if ! process_running?(pid)
            break
          end
          if wait_response == :debugger || reader.expect(/^\(byebug\) /, 0.2) #wait 0.2 sec for a match
            puts "\n" + output_buffer.string.split("\n").reverse[0..10].reverse.join("\n")
            user_input = STDIN.gets.chomp
            writer.puts user_input
            sleep 0.2 # give it a moment to exit if it wants to
          else
          #   # did not see ">" within 2 seconds
          #   puts "foo.fail"
          end
          # break unless process_running?(pid)
        end

         read_into_buffer(reader, output_buffer)
      end
    else
      read_into_buffer(reader, output_buffer)
    end
  end
  output_buffer
end

def run_this(spec, update_file, retries = 0)
  # in a successful run there's nothing in STDERR (2)
  # it's all STDOUT (1)
  verbosable = VERBOSE || AUTO_VERBOSE > 0

  run_line ="bundle exec rspec #{verbosable ? '--format=documentation' : ''} #{spec} 2>&1"
  # $stderr.puts("XXX running: #{run_line}")
  # Redirecting STDERR to STDOUT because rspec is...
  # They've made "interesting" choices about what goes where
  output_buffer = interactive_run_handler(run_line, StringIO.new(""))

  # Getting the exit code from PTY.spawn requires calling
  # Process.wait(pid)
  # but that just waits until it exits which will block,
  # so... just gonna have to do without that unless
  # you, my brilliant reader, know a workaround.

  output = unescape(output_buffer.string)
  # $stderr.puts("XXX escaped output: \n#{output}")

  if output.match(/^[A-Z]+[a-z]+\w+Error:/)
    puts "\n‚ö†Ô∏è Problems encountered: \n\t#{output.split("\n").first(10).join("\n\t")}\n..."
    # for whatever reason rspec sends SOME errors to standard out
    # not standard error
    exit 1
  elsif output.match(/(Run `bundle install`|Bundler::GemNotFound|Bundler could not find compatible versions|bundler: command not found: rspec)/m)
    if output.match(/could not find compatible versions/m)
      puts "\nBundler issue you'll have to address..."
      puts standard_error.split("\n")[0..20].join("\n")+"\n..."
      exit 1
    end
    puts "\nYou need to bundle"
    puts "I'll do that for you. Gimme a minute..."
    if retries == 0
      bundle_output, bundle_standard_error, bundle_status = Open3.capture3( "bundle install")
      if bundle_status.exitstatus == 0
        run_this(spec, update_file, 1)
      else
        puts bundle_standard_error
        puts bundle_output
        puts "\n\n\n"
        puts "Nope. I failed to bundle for you. Please reference any errors listed above"
        exit bundle_status.exitstatus
      end
    else
      exit 2
    end
  elsif output.match(/Could not locate Gemfile or \.bundle\/ directory/m)
    puts "\n‚ö†Ô∏è Could not locate Gemfile or .bundle/ directory"
    exit 3
  end

  new_run_data = process_rspec_output(output)
  update_record(new_run_data) if update_file
  new_run_data
end

def update_record(new_run_data)
  File.write(PAST_RUN_FILENAME, new_run_data.to_json)
end

def output_run_results(run_data)
  if run_data['failures'].size > 0
    display_failures(run_data['failures'])
  else
    puts NO_FAILURES_TEXT
  end
end

def display_last_run(past_run_data)
  failures_count = past_run_data.fetch('failures', {})
  if failures_count.size > 0
    puts "Displaying failures (#{failures_count})"
    display_failures(past_run_data['failures'])
  else
    puts "No past failure data. Please run a spec through me."
  end
end

def display_files(past_run_data)
  last_output = nil
  items_displayed = 0
  past_run_data["failures"].each_with_index do | failure, idx |
    this_output = printable_file_and_line_num(failure)
    if this_output != last_output
      puts "#{idx + 1}: #{this_output}"
      items_displayed += 1
      last_output = this_output
    end
  end
  if items_displayed < past_run_data["failures"].size
    puts "\n\n\tNOTE: some duplicate results excluded"
    puts "\tThis just means some common problem is causing multiple"
    puts "\ttests to fail in the same way."
    puts "\n\trun `rtest` with no args to see the full list."
  end
end

def rerun_run_number(num, line_mod, past_run_data)
  idx = num - 1
  if past_run_data["failures"].size > 0 && past_run_data["failures"][idx]
    line_num = past_run_data["failures"][idx]["line_number"].to_i
    line_num += line_mod
    if past_run_data["failures"][idx]["spec_file"].nil?
      spec = past_run_data["failures"][idx]["file_full_path"]
      spec += ":#{line_num}" if line_num
    else
      line_num = past_run_data["failures"][idx]["spec_file_line_number"].to_i
      line_num += line_mod

      spec = past_run_data["failures"][idx]["spec_file_full_path"]
      spec += ":#{line_num}" if line_num
    end
    puts "Running: #{spec}\n#{past_run_data["failures"][idx]["message"]}\n\n----------------------------\n"
    # output_run_results(run_this(spec, false))
    run_data = run_this(spec, false)
    puts NO_FAILURES_TEXT if run_data['failures'].size == 0
  else
    STDERR.puts("I don't seem to have data on run #{idx + 1}")
  end
end

def is_ignorable_detail(line)
  !! /^\s+#\s+/.match(line)
end

def with_captured_stdout
  original_stdout = $stdout  # capture previous value of $stdout
  $stdout = StringIO.new     # assign a string buffer to $stdout
  yield                      # perform the body of the user code
  $stdout.string             # return the contents of the string buffer
ensure
  $stdout = original_stdout  # restore $stdout to its previous value
end



# -------------------------

past_run_data = {"failures" => []}

if File.exist?(PAST_RUN_FILENAME) && ! TEST_MODE
  begin
    past_run_data = JSON.parse(File.read(PAST_RUN_FILENAME))
  rescue StandardError => e
    STDERR.puts("problem parsing #{PAST_RUN_FILENAME}: #{e.message}")
  end
end

if TEST_MODE
  if ! File.exist? @options[:test_file]
    STDERR.puts "Unable to find test file: #{@options[:test_file]}"
    exit 1
  end
  if ! File.exist? @options[:expected_output_file]
    STDERR.puts "Unable to find expected test output file: #{@options[:expected_output_file]}"
    exit 1
  end
  generated_output = with_captured_stdout do
    process_rspec_output(File.read(@options[:test_file]))
  end
  if generated_output != File.read(@options[:expected_output_file])
    tempfile = Tempfile.new('foo')
    tempfile.write(generated_output)
    tempfile.close
    STDERR.puts "Output didn't match expectations. Diff below"
    STDERR.puts "< == expected output"
    STDERR.puts "> == actual output"
    STDERR.puts "--------------------------------------------------------"
    STDERR.puts `diff #{@options[:expected_output_file]} #{tempfile.path}`
    STDERR.puts "--------------------------------------------------------"
    STDERR.puts "\n Do you want to save the tempfile? [y|N]: "

    response = gets.chomp.downcase

    if response != "y"
      tempfile.unlink
      exit 0
    else
      temp_copy = "actual_test_output.txt"
      `cp #{tempfile.path} #{temp_copy}`
      STDERR.puts "Tempfile saved. It's at: #{temp_copy}"
      tempfile.unlink
      exit 1
    end
  end


elsif INPUT.nil?
  display_last_run(past_run_data)
elsif /.*_spec.rb(:\d+)?$/.match(INPUT) \
  || INPUT=="all" \
  || INPUT=="last_file" \
  || /\S+\/$/.match(INPUT) # ends with a slash, prolly a directory
  if INPUT != "all" && INPUT != "last_file"
    puts "Running specs in #{INPUT}\n"
    # must be a spec file
    updated_run_data = run_this(INPUT, true)
  elsif INPUT == "last_file"
    if past_run_data["failures"].empty?
      puts "No file data from last run"
      exit 64 # EX_USAGE
    end
    last_file = past_run_data["failures"]
      .map{|f| f["spec_file"] || f["file"]}
      .select{|f| f.end_with?("_spec.rb")}
      .last
    puts "Running #{last_file}...\n"
    updated_run_data = run_this(last_file, true)
  elsif INPUT == "all"
    puts "Running ALL specs...\n"
    updated_run_data = run_this("", true)
  end
  # output_run_results(updated_run_data)
  puts NO_FAILURES_TEXT if updated_run_data['failures'].size == 0
elsif /^\d+$/.match(INPUT)
  line_mod = ARGV.size > 1 ? ARGV[1].to_i : 0
  rerun_run_number(INPUT.to_i, line_mod, past_run_data)
elsif INPUT == "rerun"
 if past_run_data["failures"].size == 0
   puts "No past failures found to rerun."
   exit 0
 end
 run_range = (1..past_run_data["failures"].size)
 run_range.each do | num |
  rerun_run_number(num, 0, past_run_data)
 end
elsif INPUT == "kill" &&  /^\d+(-\d+)?$/.match(ARGV[1].to_s)
  indexes = Array(ARGV[1].to_i - 1)
  if /^\d+-\d+?$/.match(ARGV[1])
    x, y = ARGV[1].split('-').map(&:to_i)
    # If we work from highest to lowest we can
    # avoid complications resulting
    # from shortening an array while iterating over it

    if x < y
      indexes = ((x - 1)..(y - 1)).to_a.reverse
    elsif x == y
      indexes = [x]
    else
      indexes = ((x - 1)..(y - 1)).to_a
    end

  end

  indexes.each do |idx|
    puts "killing #{idx}: #{past_run_data["failures"][idx]["message"]}"
    # display_failure(past_run_data["failures"][idx], idx)
    past_run_data["failures"].slice!(idx)
  end
  puts "-------------------------------------------------\n"
  puts "-------------------------------------------------\n"
  update_record(past_run_data)
  display_last_run(past_run_data)
elsif INPUT == "file" &&  /^\d+$/.match(ARGV[1].to_s)
  idx = ARGV[1].to_i - 1
  if past_run_data.size > idx
    puts past_run_data["failures"][idx]["file"]
  else
    exit 75 # EX_TEMPFAIL (user input)
  end
elsif INPUT == "files"
  display_files(past_run_data)
elsif /\.rb$/.match(INPUT)
  puts "üõë That's a ruby file, but not an rspec (*_spec.rb) file."
elsif /^-{0,2}h(?:elp)?$/.match(INPUT)
  puts USAGE
end

